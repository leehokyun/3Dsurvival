` 키를 누르면 카메라 시점 전환이 됩니다.(키보드 상단 숫자키 1 왼쪽에 있는 키)

케이크 아이템을 먹으면 속도가 10초간 5배 부스트됩니다.

모닥불 옆에 있는 동그란 원판은 점프대입니다.

물가에는 움직이는 플랫폼이 있습니다.

------------------------------------------------------------------------

## 꾸준실습

### Q1. 숙련 1강 ~ 숙련 3강

#### Q1-1  
입문 주차와 비교해서 입력 받는 방식의 차이와 공통점을 비교해보세요.  

**A.**  
- **입문 주차의 입력 받는 방식**:  
  인풋시스템의 `SendMessage` 기능을 통해 전역적으로 메서드에 접근한 뒤, 문자열을 비교해서 메서드를 호출하는 방식이다. 런타임 성능에 비효율적일 수 있다. `SendMessage`를 통해 `Action Event`가 실행되면 해당 `Action`을 구독 중인 각각의 메서드가 호출되는 방식이다.

- **숙련 주차의 입력 받는 방식**:  
  `InputSystem`과 이벤트를 직접 연결해서 특정 메서드를 호출한다. 성능이 좋고 관리가 쉽다.

- **공통점**:  
  둘 다 `InputSystem`을 통해 입력을 받는다.

#### Q1-2  
`CharacterManager`와 `Player`의 역할에 대해 고민해보세요.  

**A.**  
- `Player`는 `controller`, `condition`, `equip`, `itemData`의 정보를 갖고 있다.  
  이러한 플레이어의 정보를 `CharacterManager`가 들고 있다.  
  외부에서 `CharacterManager`를 통해 전역적으로 플레이어의 정보에 접근할 수 있게 해주는 역할이다.

- 외부에서 플레이어의 `condition`에 접근하려면, `외부 -> CharacterManager -> Player -> condition`으로 접근할 수 있게 된다.

#### Q1-3  
핵심 로직을 분석해보세요 (`Move`, `CameraLook`, `IsGrounded`).

**A.**  
- **MOVE**:  
  `InputSystem`에서 WASD 키값에 각각의 이벤트를 연결하여 등록해놓는다. 키 입력이 들어갈 때마다 벡터값이 변하고, 그 값을 통해 리지드바디의 속도값에 `Vector3` 값을 넣어주는 함수를 지속적으로 `FixedUpdate`에서 호출하여 플레이어가 이동하게 된다.

- **CameraLook**:  
  `InputSystem`에서 마우스 델타값 변화에 따라 호출되는 이벤트를 연결하여 등록해놓는다. 마우스 델타값이 변할 때 카메라의 각도도 변하게 한다.

- **IsGrounded**:  
  플레이어의 아래쪽으로 레이 4개를 쏘아서, 레이어 마스크를 식별한다. `Ground` 레이어 마스크인지 여부를 `true` 혹은 `false`로 반환한다.

#### Q1-4  
`Move`와 `CameraLook` 함수를 각각 `FixedUpdate`, `LateUpdate`에서 호출하는 이유에 대해 생각해보세요.

**A.**  
`Update`는 매 프레임마다 호출된다. 그래서 초당 프레임 수에 따라서 호출 빈도가 달라진다. 저사양 컴퓨터는 초당 60프레임, 고급 컴퓨터는 초당 120프레임이라면, 고급 컴퓨터에서는 두 배 더 많은 호출을 할 수 있게 된다. 달리기 게임이라고 치면 두 배 더 멀리 갈 수 있는 것이다. 형평성이 떨어진다. 반면 `FixedUpdate`는 프레임에 상관없이 시간 간격에 따라 호출된다. 프레임이 어떻던 간에 고정된 0.02초마다 실행되기 때문에 컴퓨터 간의 차이에도 형평성 문제가 없다. 물리 엔진 관련 작업에 적합하다. `LateUpdate`는 모든 `Update`가 끝난 후에 호출된다. 플레이어 오브젝트가 `update`에서 위치를 변경하면 그 이후에 카메라는 그 위치에 맞춰서 따라가는 것이다.

---

### Q2. 숙련 4강 ~ 숙련 8강

#### Q2-1  
별도의 UI 스크립트를 만드는 이유에 대해 객체지향적 관점에서 생각해보세요.  

**A.**  
UI와 관련된 코드가 한 군데에 모여있으면 코드가 복잡해지지 않는다. 가독성이 좋아진다. 단일 책임 원칙에 따라 UI의 변화에만 집중하게 한다. UI 컴포넌트로 정의되어 있기 때문에 다른 씬이나 다른 UI에서도 코드 중복 없이 재사용할 수 있다. 모듈화되어 있기 때문에 코드를 중복해서 새로 구현하지 않고 재사용할 수 있다. UI 로직이 별도로 분리되어 있으면 디버깅과 테스트가 쉽다.

#### Q2-2  
인터페이스의 특징에 대해 정리해보고 구현된 로직을 분석해보세요.  

**A.**  
- 인터페이스는 구현할 메서드와 속성의 큰 그림을 잡아준다. 특정 기능을 강제로 정의하게 만든다.
- 추상화된 방법으로 구현은 클래스에 맡겨 버리는 것이다. 클래스와 달리 다중 상속이 가능하다. `IDamagable`, `IMovable`과 같은 인터페이스를 동시에 상속받을 수 있다.  
- 인터페이스 조합에 따라 다양한 기능을 쓸 수 있게 한다.
- 객체 간 상호작용이 표준화되므로 코드가 확장되거나 수정되어도 간단하게 유지보수할 수 있다.

`IInteractable` 인터페이스에는 `GetInteractPrompt()`와 `OnInteract()`가 있다. 이 인터페이스를 상속받은 `ItemObject`는 반드시 위 두 가지 메서드를 구현해야 하는데, 구현만 한다면 어떻게 구현하든 클래스 몫이다. `IDamageable` 인터페이스에는 `TakePhysicalDamage`가 있고 이를 상속받은 `PlayerCondition`은 반드시 이 메서드를 구현해야 한다.

여러 클래스들에 공통으로 들어갈 걸로 예상되는 속성, 즉 메서드를 인터페이스가 들고 있는 것이다. 그리고 메서드를 반드시 구현하도록 강제하는 게 인터페이스다.

#### Q2-3  
핵심 로직을 분석해보세요. (UI 스크립트 구조, `CampFire`, `DamageIndicator`)

**A.**  
- **Condition 클래스**:  
  `Condition` 클래스를 통해 플레이어가 아니더라도 모든 클래스들의 다양한 상태(예: 체력, 스태미나, 허기, 에너지 레벨)를 관리하고 UI를 업데이트한다. `Condition` 데이터가 정의된 `Condition` 클래스에서는 값의 증감을 관리하고 UI에 퍼센트를 반영한다.

- **PlayerCondition 클래스**:  
  플레이어의 전체 상태를 관리하고, 값을 지속적으로 깎거나 추가하는 등 업데이트를 수행하여 플레이어 상태를 관리한다. `uiCondition`은 `Condition`의 객체들을 묶어서 UI에서 한 번에 관리할 수 있도록 하며, 각각의 상태(`health`, `hunger`, `stamina`)를 `PlayerCondition` 클래스가 간접적으로 접근할 수 있게 한다.

- **CampFire**:  
  `OnTriggerEnter`될 경우 `IDamageable`을 갖고 있는 콜라이더의 체력을 깎는다.

- **DamageIndicator**:  
  `onTakeDamage` 이벤트가 외부에서 실행될 경우, `Flash()` 메서드가 호출되어 화면에 빨간 플래시 효과를 표시하는 구조다. 코루틴을 사용하여 시간이 지날 때 자연스럽게 색깔이 변화하도록 하였다. (연속적인 변화 처리)

---

### Q3. 숙련 9강 ~ 숙련 11강  

- `Interaction` 기능의 구조와 핵심 로직을 분석해보세요.
- `Inventory` 기능의 구조와 핵심 로직을 분석해보세요.

#### Q3-1  
A. **Interaction**:  
   지속적으로 카메라 스크린 중앙에 `Ray`를 쏴서 `IInteractable` 인터페이스를 갖고 있는 객체인지 확인한다. 만약 맞다면, 그 오브젝트의 정보를 캐싱해온다. 화면상에는 그 객체를 설명하는 텍스트가 나타나며, `E`키를 누르면 그 객체와 상호작용이 실행된다.

#### Q3-2  
A. **Inventory**:  
   `UI` 관련 기능을 관리하고, 아이템을 표시하며, 아이템 사용, 장착, 버리기 동작을 제어한다. 아이템 관리, UI 업데이트, 인터랙션을 제어한다. `slots` 배열과 `slotPanel` 트랜스폼을 사용해 인벤토리의 각 슬롯을 관리한다. `slots`에는 아이템을 담을 수 있는 `ItemSlot` 배열이 있어 인벤토리 창의 각 위치에 아이템 정보를 표시한다. 선택된 아이템의 이름과 설명, 속성 등의 정보를 표시하며, 아이템의 타입과 장착 상태에 따라 `useButton`, `equip`, `unequip`, `drop` 버튼을 활성화한다. `Start` 메서드에서 `CharacterManager.Instance.Player.controller.Inventory`와 `CharacterManager.Instance.Player.addItem` 이벤트에 구독하여 인벤토리를 여닫는 기능과 아이템 추가 기능을 초기화한다.

------------------------------------------------------------------------

### Q1. 숙련 12강 ~ 숙련 14강  

### Q1-1 
**Equipment와 EquipTool 기능의 구조와 핵심 로직을 분석해보세요.**
- A. Equipment: Player오브젝트의 컴포넌트로 들어간다. 플레이어가 현재 장착한 장비가 어떤 건지 관리하고 & 장착과 해제를 관리한다. 장착해제시 현재 장착한 장비가 있다면 파괴하고 'curEquip'에 새 장비를 집어넣는다.
공격버튼이 눌리면 공격할 수 있는 상태인지 조건을 확인한 후, 장착한 장비에다가 공격버튼이 눌렸다는 메서드를 호출한다.

- A. EquipTool: 무기 오브젝트의 컴포넌트로써 무기의 속성들을 관리한다. 공격력, 공격속도, 공격거리, 스태미나소모량, 자원채취용 무기 여부, 데미지를 관리한다.
공격이 눌렸을 때 공격중이 아니라면 다시한번 조건을 체크해서 스태미나 사용 조건에 맞다면 애니메이터에다가 공격을 실행하도록 트리거를 실행한다. 그리고 onCanAttack()메서드를 attackRate간격만큼 실행시킨다.
애니메이터에서 특정 프레임에 OnHit Event가 실행된다. OnHit()가 실행되면 레이를 쏴서 체크하여 이 장비가 리소스 수집 장비이고, 맞은 녀석이 리소스 레이어를 들고있다면 리소스 수집하라는 메서드가 호출된다.
  
**Resource 기능의 구조와 핵심 로직을 분석해보세요.**
- A. Resource: 맵 위에 올라가있는 나무, 바위 등이다. 채취당할 시 씬에 생성할 itemData를 들고있다. 한번 채취시 생성될 양, 최대 생성량을 세팅할 수 있다.
EquipTool의 Onhit에 의해 Gather가 실행될 때 리소스를 떨어뜨리고 최대생성량(capacy)를 넘으면 더이상 for문이 break되면서 생성이 되지 않는다.





